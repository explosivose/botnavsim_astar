//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
namespace Astar
{
	
	/// <summary>
	/// Square graph.
	/// </summary>
	public class SquareGraph {
		private int X = 25;
		private int Y = 25;
		public float spacing = 1f;
		public Node[,] graph {get; set;}
		
		public SquareGraph(Vector3 min, Vector3 max, int nodes) {
			X = Y = nodes;
			spacing = (max.x - min.x)/(float)nodes;
			spacing = Mathf.Max(spacing, (max.z - min.z)/(float)nodes);
			graph = new Node[X,Y];
			for (int x = 0; x < X; x++) {
				for (int y = 0; y < Y; y++) {
					Vector3 position = new Vector3(x * spacing, 0, y * spacing);
					position += (min + Vector3.up*(max.y + min.y)/2f);
					Node n = new Node(position, null, this);
					graph[x,y] = n;
				}
			}
			
			ConnectNodes();
		}
		
		public void RevealObstacles() {
			// call every Node.CheckForObstacles()
			// note that Physics obstacleLayer should be shared with 
			// this plugin before this is implemented...
			throw new NotImplementedException();
		}
		
		void ConnectNodes() {
			for (int x = 0; x < X; x++) {
				for (int y = 0; y < Y; y++) {
					Node n = graph[x,y];
					if (y > 0) {
						n.connected.Add(graph[x,y-1]);
						if (x > 1)
							n.connected.Add(graph[x-1,y-1]);
						if (x < X-1)
							n.connected.Add(graph[x+1,y-1]);
					}
					if (x > 0) {
						n.connected.Add(graph[x-1,y]);
						if (y < Y-1)
							n.connected.Add(graph[x-1,y+1]);
					}
					if (x < X-1) {
						n.connected.Add(graph[x+1,y]);
						if (y < Y-1)
							n.connected.Add(graph[x+1,y+1]);
					}
					if (y < Y-1) {
						n.connected.Add(graph[x,y+1]);
					}
				}
			}
		}
		
		/// <summary>
		/// Returns the Node with position nearest to a specified world location.
		/// </summary>
		public Node NearestNode(Vector3 position) {
			Node nearestNode = graph[0,0];
			float d1 = Mathf.Infinity;
			for (int x = 0; x < X; x++) {
				for (int y = 0; y < Y; y++) {
					float d2 = Vector3.Distance(graph[x,y].position, position);
					if (d2 < d1) {
						nearestNode = graph[x,y];
						d1 = d2;
					}
				}
			}
			return nearestNode;
		}
		
		/// <summary>
		/// Returns the unobstructed Node with position nearest to a specified world location.
		/// </summary>
		public Node NearestUnobstructedNode(Vector3 position) {
			Node nearestNode = graph[0,0];
			float d1 = Mathf.Infinity;
			for (int x = 0; x < X; x++) {
				for (int y = 0; y < Y; y++) {
					if (graph[x,y].type != Node.Type.obstructed) {
						float d2 = Vector3.Distance(graph[x,y].position, position);
						if (d2 < d1) {
							nearestNode = graph[x,y];
							d1 = d2;
						}
					}
				}
			}
			return nearestNode;
		}
		
		public void DrawGizmos() {
			for (int x = 0; x < X; x++) {
				for (int y = 0; y < Y; y++) {
					graph[x,y].DrawGizmos();
					//graph[x,y].DrawLines();
				}
			}
		}
		
		public void DrawDebug(float height) {
			for (int x = 0; x < X; x++) {
				for (int y = 0; y < Y; y++) {
					graph[x,y].DrawLines(height);
				}
			}
		}
	}
	
	
}

