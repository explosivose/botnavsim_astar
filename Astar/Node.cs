//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;
namespace Astar
{
	
	/// <summary>
	/// Node.
	/// </summary>
	public class Node {
		public enum State {
			regular,
			start,
			destination,
			path,
			open,
			closed
		}
		public enum Type {
			walkable,
			obstructed,
			unexplored
		}
		
		public List<Node> connected = new List<Node>();
		
		/// <summary>
		/// Set true if node state, type, parent of child is changed.
		/// </summary>
		public bool hasChanged;
		
		public Vector3 position {
			get; private set;
		}
		
		
		public float G { get; private set; }		// Astar G score
		public float H { get; private set; }		// Astar heuristic
		public float F { get { return G + H; } }	// Astar F score
		public int index { get; private set; } 		// unique index
		public Color color { get; private set; }	// debug color
		
		public Node parent {
			get { return _parent; }
			set {
				_parent = value;
				hasChanged = true;
				if (_parent) {
					G = _parent.G;
					G += Vector3.Distance(position, _parent.position);
				}
				else {
					G = 0f;
					type = type;
				}
			}
		}
		
		public Node child {
			get { return _child; }
			set {
				_child = value;
				hasChanged = true;
			}
		}
		
		public Node destination {
			get { return _destination; }
			set {
				_destination = value;
				if (_destination) {
					H = Mathf.Abs(position.x - _destination.position.x);
					H += Mathf.Abs(position.y - _destination.position.y);
					H += Math.Abs(position.z - _destination.position.z);
				}
				else {
					H = 0f;
				}
			}
		}
		
		public State state {
			get { return _state; }
			set {
				_state = value;
				hasChanged = true;
				switch(_state) {
				case State.regular:
					type = _type;
					break;
				case State.start:
					color = Color.Lerp(Color.clear, Color.yellow, 0.75f);
					break;
				case State.destination:
					color = Color.green;
					break;
				case State.path:
					color = Color.Lerp(Color.clear, Color.green, 0.75f);
					break;
				case State.closed:
					color = Color.Lerp(Color.clear, Color.cyan, 0.75f);
					break;
				case State.open:
					color = Color.Lerp(Color.clear, Color.magenta, 0.75f);
					break;
				default:
					color = Color.magenta;
					break; 
				}
			}
		}
		
		public Type type {
			get{ return _type; }
			set {
				_type = value;
				hasChanged = true;
				if (state != State.regular) return;
				switch(_type){
				case Type.obstructed:
					color = Color.Lerp(Color.clear, Color.red, 0.75f);
					break;
				case Type.walkable:
					color = Color.Lerp(Color.clear, Color.green, 0.25f);
					break;
				case Type.unexplored:
					color = Color.Lerp(Color.clear, Color.black, 0.25f);
					break;
				}
			}
		}
		
		
		private static int node_count;
		
		private float _spacing;
		private State _state;
		private Type _type;
		private Node _parent;
		private Node _child;
		private Node _destination;
		
		public static implicit operator bool (Node n) {
			return n != null;
		}
		
		/// <summary>
		/// Initializes a new instance of the <see cref="Astar.Node"/> class.
		/// </summary>
		/// <param name="location">This node location.</param>
		/// <param name="nodePrefab">Node prefab used for runtime graph rendering. Set to null to ignore.</param>
		/// <param name="g">The graph that this node belongs to.</param>
		public Node(Vector3 location, float spacing) {
			index = node_count++;
			position = location;
			state = State.regular;
			type = Type.unexplored;
			color = Color.white;
			_spacing = spacing;
		}
		
		/// <summary>
		/// Check for obstacles at node position
		/// (Physics.layer not implemented yet!)
		/// </summary>
		public void CheckForObstacles() {
			type = Type.walkable;
			Collider[] colliders = Physics.OverlapSphere(position, _spacing * 0.5f);
			foreach(Collider c in colliders) {
				if (!c.isTrigger) {
					type = Type.obstructed;
				}
			}
		}
		
		public float TentativeG(Node potentialParent) {
			float tG = potentialParent.G;
			tG += Vector3.Distance(position, potentialParent.position);
			return tG;
		}
		
		// Draw debug information in worldspace (should be called by OnDrawGizmos() )
		public void DrawGizmos() {
			
			if (type == Type.obstructed) {
				Gizmos.color = Color.red;
				Gizmos.DrawWireCube(
					position,
					Vector3.one
					);
				return;
			}
			
			if (state == State.regular) return;
			
			Gizmos.color = color;
			Gizmos.DrawWireCube(
				position,
				Vector3.one * _spacing * 0.25f
				);
			
			if (parent) {
				Gizmos.DrawLine(position, parent.position);
			}
			else {
				foreach(Node n in connected) {
					Gizmos.DrawLine(position, n.position);
				}
			}
			
		}
		
		public void DrawLines(float height) {
			position = new Vector3(position.x,height,position.z);
			if (type == Type.obstructed) {
				Draw.Instance.Cube(
					position, Vector3.one * 0.25f,
					Color.red);
				return;
			}
			
			if (state == State.regular) return;
			
			Draw.Instance.Line (
				position, position + Vector3.down,
				color);
			
			if (parent) {
				Draw.Instance.Line(
					position,parent.position,
					color);
			}
			else {
				foreach (Node n in connected) {
					Draw.Instance.Line(
						position, n.position, 
						color);
				}
			}
			
		}
	}
	
	
}

