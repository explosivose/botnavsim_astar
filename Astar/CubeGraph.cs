//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;
namespace Astar {
	
	public class CubeGraph : Graph {
		
		public override float spacing { get; set; }
		public override int nodeCount {
			get {
				return graph.Length;
			}
		}
		
		private Node[,,] graph;
		private Bounds bounds;
		private int X_SIZE, Y_SIZE, Z_SIZE; // cube dimensions in number of nodes
		
		/// <summary>
		/// Initializes a new instance of the <see cref="Astar.CubeGraph"/> class.
		/// </summary>
		/// <param name="bounds">Bounds.</param>
		/// <param name="nodeSpacing">Node spacing.</param>
		public CubeGraph (Bounds bounds, float nodeSpacing) {
			this.bounds = bounds;
			spacing = nodeSpacing;
			X_SIZE = Mathf.CeilToInt(bounds.size.x/spacing);
			Y_SIZE = Mathf.CeilToInt(bounds.size.y/spacing);
			Z_SIZE = Mathf.CeilToInt(bounds.size.z/spacing);
			graph = new Node[X_SIZE,Y_SIZE,Z_SIZE];
			for(int x = 0; x < X_SIZE; x++) {
				for(int y = 0; y < Y_SIZE; y++) {
					for(int z = 0; z < Z_SIZE; z++) {
						Vector3 position = bounds.min + new Vector3(x*spacing, y*spacing, z*spacing); 
						Node n = new Node(position, spacing);
						graph[x,y,z] = n;
					}
				}
			}
			Debug.Log("A*: cube graph created (" + X_SIZE + "," + Y_SIZE + "," + Z_SIZE + ")");
			AddNodeConnections();
		}
		
		/// <summary>
		/// Finds the nearest node.
		/// </summary>
		/// <returns>The nearest node.</returns>
		/// <param name="location">Location.</param>
		public override Node FindNearestNode(Vector3 location) {
			location -= bounds.min; // normalize to world bounds
			// calculate graph indexes from normalized location
			int x = Mathf.Clamp(Mathf.RoundToInt(location.x/spacing),0,X_SIZE-1);
			int y = Mathf.Clamp(Mathf.RoundToInt(location.y/spacing),0,Y_SIZE-1);
			int z = Mathf.Clamp(Mathf.RoundToInt(location.z/spacing),0,Z_SIZE-1);
			return graph[x,y,z];
		}
		
		/// <summary>
		/// Finds the nearest unobstructed node.
		/// </summary>
		/// <returns>The nearest unobstructed node.</returns>
		/// <param name="location">Location.</param>
		public override Node FindNearestUnobstructedNode(Vector3 location) {
			
			Node n = FindNearestNode(location);
			if (n.type != Node.Type.obstructed) return n;
			
			Vector3 offset = new Vector3(0f,0f,0f);
			// move along each axis one axis at a time in pos and neg directions and increasing distances
			for(int attempt = 1; attempt < 100; attempt++) {
				for (float sign = -1f; sign <= 1f; sign += 2f) {
					offset.x = (attempt % 3 == 1) ? attempt * spacing * sign : 0f;
					offset.y = (attempt % 3 == 2) ? attempt * spacing * sign : 0f;
					offset.z = (attempt % 3 == 0) ? attempt * spacing * sign : 0f;
					n = FindNearestNode(location + offset);
					if (n.type != Node.Type.obstructed) return n;
				}
			}
			// errorrrr
			return n;
		}
		
		/// <summary>
		/// Reveals the obstacles.
		/// </summary>
		public override void RevealObstacles () {
			for(int x = 0; x < X_SIZE; x++) {
				for(int y = 0; y < Y_SIZE; y++) {
					for(int z = 0; z < Z_SIZE; z++) {
						graph[x,y,z].CheckForObstacles();
					}
				}
			}
		}
		
		/// <summary>
		/// Draws lines to illustrate the nodes in the graph as they are searched.
		/// </summary>
		public override void DrawNodes() {
			for(int x = 0; x < X_SIZE; x++) {
				for(int y = 0; y < Y_SIZE; y++) {
					for(int z = 0; z < Z_SIZE; z++) {
						Node n = graph[x,y,z];
						if (n.state == Node.State.path) {
							Draw.Instance.Line(n.position, n.parent.position, n.color);
						}
					}
				}
			}
		}
		
		public override void DrawGizmos () {
			for(int x = 0; x < X_SIZE; x++) {
				for(int y = 0; y < Y_SIZE; y++) {
					for(int z = 0; z < Z_SIZE; z++) {
						Node n = graph[x,y,z];
						if (n.type == Node.Type.obstructed) {
							Draw.Instance.Cube(n.position, Vector3.one * spacing * 0.5f, Color.red);
						}
						else if (n.state == Node.State.path) {
							Draw.Instance.Line(n.position, n.parent.position, n.color);
						}
					}
				}
			}
		}
		
		/// <summary>
		/// Connects nodes
		/// </summary>
		private void AddNodeConnections() {
			// axis aligned connections only
			for(int x = 0; x < X_SIZE; x++) {
				for(int y = 0; y < Y_SIZE; y++) {
					for(int z = 0; z < Z_SIZE; z++) {
						Node n  = graph[x,y,z];
						if (x < X_SIZE-1) {
							n.connected.Add(graph[x+1,y,z]);
						}
						if (x > 0) {
							n.connected.Add(graph[x-1,y,z]);
						}
						if (y < Y_SIZE-1) {
							n.connected.Add(graph[x,y+1,z]);
						}
						if (y > 0) {
							n.connected.Add(graph[x,y-1,z]);
						}
						if (z < Z_SIZE-1) {
							n.connected.Add(graph[x,y,z+1]);
						}
						if (z > 0) {
							n.connected.Add(graph[x,y,z-1]);
						}
					}
				}
			}
		}
		
		
	}
}

